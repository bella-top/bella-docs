# 为什么选择Responses API?

## 官方定义
> Responses API 是一个用于构建功能强大的代理类应用程序的统一接口。它包含很多内置工具，如：网络搜索，文件搜索，计算机使用，代码解释器和远程MCP。且对文本和图像原生支持支持多模态。

Bella Assistant服务对Openai的Responses API做了全面地兼容和升级。比如内置工具的全模型支持以及多模态输入的全模型支持等等。并且整合了Bella体系下的各个能力服务，为Agent的搭建提供了强大的支持，让Agent的搭建变得更简单更高效。

## 完全覆盖Chat Completions
支持chat completions的所有功能以及**全部模型**，非store模式可以理解为功能更丰富的chat completions接口

## 使用便捷
相比assistant api使用更方便，无需创建智能体

## 丰富的多模态输入/输出
- 全模型支持File Input，以 `purpose`为`assistants`的方式，上传到`file-api`后，可以直接使用File Input，LLM将根据文件内容生成响应
- 全模型支持Audio Input，支持直接以语音作为输入
- 兼容chat completions的图片识别能力，后续会扩展为全模型支持
- 内置生图工具支持图像输出
- 未来会扩展语音输出的能力（敬请期待）

## 强大的内置工具
- 支持集成私有知识库，私有知识的上下文组织是使用LLM的痛点之一，responses api提供了file-search工具，结合`bella-knowledge`使用，让LLM掌握你的私有知识更加简单
- 支持网络搜索，原生支持web search工具，使用简单，可以减少模型幻觉，让LLM的知识储备可以即时更新
- 支持MCP工具，可以让LLM与应用服务进行交互，获取私有知识或者执行你的既定流程，为LLM提供与外部进行交互的窗口
- MCP工具支持服务调用时的审批操作，保障MCP服务调用的安全性，Client端在实现与用户交互时更方便
- 支持生图工具，可生成图片，`store`模式下上传到s3返回图片的url，`非store模式`下返回Base64String
- 支持自主生成代码/工具/子Agent，来解决用户的问题，完成复杂任务（敬请期待）

## 支持 `store`和`非store`双模式

### `store`模式
- `store`模式为默认模式，在此模式下，可使用response-api为客户端提供上下文管理的能力
- `store`模式，进行请求只需要携带`previous_response_id`或`conversation`即可在请求LLM时保留对话上下文
- `store`模式便于轻量级应用的快速搭建

### `非store`模式
- `非store`模式拥有更高的性能和安全性，在response-api的服务端完全不留痕
- 适用于客户端自行管理上下文的场景
- 使用chat completions搭建的应用可以此模式快速迁移
- 相当于chat completions的扩展，可使用responses api的全部工具和多模态输入能力

## 可重复使用的 `previous_response_id`
- 同一`previous_response_id`支持并发使用/重复使用
- 如果某一次输入错误，可以使用上一次响应的`response_id`作为`previous_response_id`，防止污染上下文
- 这意味着用户某一次回答不满意时，Client端可以基于此特性非常简单地实现删除某条消息的操作
- 可以在同一对话中进行不同提示词的A/B Test等实验性操作，上下文互不干扰
- 不同的用户也可以基于同一会话并发地进行请求，且上下文互不干扰，Client端可以基于此实现用户对某次会话的分享

## 更多高级特性
- 根据文件、网页生成的回答，提供信息的引用来源
- 支持Local Shell Tool，可以借此搭建应用，让LLM操作你的电脑
- 支持Custom Tool，可以理解为Response Format的平替，支持regex和lark语法，更方便地实现参数的提取
- 后台执行模式（敬请期待）

## 全面且严谨的协议规范
- 充分考虑了开发者搭建Agent时可能面临的各种需求
- 可以说既能包罗万象，又进行了高度抽象，设计水平极高
- 可扩展性很强，伴随着未来AI能力的发展，可以不断扩展新功能
- 对轻量级客户端很友好，顺应AI时代应用层产品快速开发、快速落地的理念

## 注意事项
- 虽然协议为开发者提供了丰富的功能，但对于一些复杂的应用场景（如长期对话的上下文管理、复杂推理等），开发者可能还需要额外的工具或者特定的配置
- 虽然协议的抽象性高，但是由于支持的能力很多，对于一些初学者或者对高级功能有需求的开发者来说，会有一定的学习曲线，理解协议的各个部分可能需要花费一定的时间
- 虽然API的设计很轻量级且易于使用，但如果应用的功能比较复杂，可能仍然需要Client端使用额外的服务或基础设施来实现更好的性能优化和稳定性
